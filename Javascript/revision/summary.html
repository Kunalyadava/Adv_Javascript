<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <!-- Execution Context 
    📚 Callstack 
    🔢 Data types (Especially Arrays, Objects, Strings) 
    🔄 Array and Object methods 
    🔗 let/var/const 
    🕳️ Hoisting, Temporal Dead Zone 
    🚫 Illegal shadowing 
    🔍 Scope, Scope chaining 
    🔄 Mutable/Immutable data types 
    🔍 Shallow and Deep copy 
    🌐 DOM (DOM methods) and BOM 
    📝 Critical Rendering Path 
    🔧 Functions 
    📄 Function Declaration 
    🗣️ Function Expression 
    🔄 Functional Programming 
    ➡️ Arrow Functions 
    📦 IIFE 
    🔑 this keyword 
    ➡️ Arrow function and this keyword 
    📞 Call, Apply, Bind 
    🔒 Closure and its uses 
    🔄 Callbacks, Callback Hell 
    🔮 Promises, promise chaining 
    ⏳ Async/Await 
    🔄 Callbacks vs promises vs async/await 
    🍛 Currying 
    🛠️ Debouncing and Throttling 
    🔍 Event Propagation 
    🔵 Bubbling 
    🎣 Capturing 
    📦 Event Delegation 
    📘 Prototype and Prototypal Inheritance 
    🧠 Memoization 
    🌀 Generator Functions 
    🔄 Event Loop, Microtasks, Macrotasks 
    🎉 Events: DOMContentLoaded, load, beforeunload, unload 
    ⏩ async/defer 
    🩹 Polyfills (Mostly asked polyfills: Promise, Promise.all, Promise.any,
     Promise.race, Promise.allSettled, call, apply, bind, map, reduce, filter, forEach, flat, fetch API) 
    🌐 Web APIs 
    ⏲️ setTimeout, setInterval 
    🔄 High Order Functions 
    🔧 Working of JS Engine ... -->

    <span>
        <div>
            <!-- 📚 Execution Context -->
            <!-- Execution context is the environment in which JavaScript code is executed.
                 It includes the variable object, scope chain, and `this` keyword. -->
            <pre>
      function foo() {
        var a = 1;
        function bar() {
          var b = 2;
          console.log(a + b); // 3
        }
        bar();
      }
      foo();
        </pre>
        </div>

        <div>
            <!-- 🔢 Callstack -->
            <!-- Callstack is a mechanism to keep track of function calls in a program.
                 It operates in a LIFO (Last In, First Out) manner. -->
            <pre>
      function first() {
        second();
        console.log('First');
      }
      function second() {
        console.log('Second');
      }
      first(); // Output: Second, First
        </pre>
        </div>

        <div>
            <!-- 🔢 Data types (Especially Arrays, Objects, Strings) -->
            <!-- JavaScript has various data types including primitive types like Strings
                 and non-primitive types like Arrays and Objects. -->
            <pre>
      let str = "Hello";
      let arr = [1, 2, 3];
      let obj = { name: "John", age: 30 };
        </pre>
        </div>

        <div>
            <!-- 🔄 Array and Object methods -->
            <!-- Arrays and Objects come with built-in methods to manipulate their content. -->
            <pre>
      arr.push(4); // Adds an element to the end of the array [1, 2, 3, 4]
      Object.keys(obj); // Returns an array of the object's keys ["name", "age"]
        </pre>
        </div>

        <div>
            <!-- 🔗 let/var/const -->
            <!-- `var` is function-scoped while `let` and `const` are block-scoped.
                 `const` is used for constants. -->
            <pre>
      var a = 1;
      let b = 2;
      const c = 3;
        </pre>
        </div>

        <div>
            <!-- 🕳️ Hoisting, Temporal Dead Zone -->
            <!-- Hoisting is JavaScript's behavior of moving declarations to the top. 
                `let` and `const` are not initialized until their definition is evaluated,
                 leading to the TDZ (Temporal Dead Zone). -->
            <pre>
      console.log(a); // undefined (hoisted)
      var a = 1;
      
      console.log(b); // ReferenceError (TDZ)
      let b = 2;
        </pre>
        </div>

        <div>
            <!-- 🚫 Illegal shadowing -->
            <!-- Illegal shadowing occurs when a variable declared with `let` or `const` is shadowed 
                by a `var` declaration in the same scope. -->
            <pre>
      let a = 1;
      {
        let a = 2; // Legal
        var a = 3; // Illegal - SyntaxError
      }
        </pre>
        </div>

        <div>
            <!-- 🔍 Scope, Scope chaining -->
            <!-- Scope determines the visibility of variables. Scope chain is used to 
                resolve variable names in nested functions. -->
            <pre>
      let a = 1;
      function outer() {
        let b = 2;
        function inner() {
          let c = 3;
          console.log(a, b, c); // 1, 2, 3
        }
        inner();
      }
      outer();
        </pre>
        </div>

        <div>
            <!-- 🔄 Mutable/Immutable data types -->
            <!-- Mutable types (objects, arrays) can be changed after creation, 
                while immutable types (strings, numbers) cannot. -->
            <pre>
      let str = "hello";
      str[0] = "H"; // No effect
      console.log(str); // "hello"
      
      let arr = [1, 2, 3];
      arr[0] = 4;
      console.log(arr); // [4, 2, 3]
        </pre>
        </div>

        <div>
            <!-- 🔍 Shallow and Deep copy -->
            <!-- Shallow copy duplicates the immediate properties of an object, 
                while deep copy duplicates everything recursively. -->
            <pre>
      let obj = { a: 1, b: { c: 2 } };
      let shallowCopy = { ...obj }; // Shallow copy
      let deepCopy = JSON.parse(JSON.stringify(obj)); // Deep copy
        </pre>
        </div>

        <div>
            <!-- 🌐 DOM (DOM methods) and BOM -->
            <!-- DOM (Document Object Model) methods manipulate HTML elements.
                 BOM (Browser Object Model) methods interact with the browser. -->
            <pre>
      document.getElementById('myId').innerText = 'Hello'; // DOM method
      window.alert('Hello from BOM'); // BOM method
        </pre>
        </div>

        <div>
            <!-- 📝 Critical Rendering Path -->
            <!-- The critical rendering path is the sequence of steps the browser takes
                 to render a web page. It includes parsing HTML, CSS, and JavaScript. -->
            <pre>
      <!DOCTYPE html>
      <html>
      <head>
        <style>/* CSS */</style>
        <script>/* JavaScript */</script>
      </head>
      <body>
        <div id="content">Hello, world!</div>
      </body>
      </html>
        </pre>
        </div>

        <div>
            <!-- 🔧 Functions -->
            <!-- Functions are reusable blocks of code. -->
            <!-- 📄 Function Declaration -->
            <pre>
      function greet() {
        console.log('Hello');
      }
        </pre>
            <!-- 🗣️ Function Expression -->
            <pre>
      const greet = function() {
        console.log('Hello');
      };
        </pre>
        </div>

        <div>
            <!-- 🔄 Functional Programming -->
            <!-- Functional programming is a paradigm where functions are first-class 
                citizens and side-effects are minimized. -->
            <pre>
      const add = (x) => (y) => x + y;
      const addTwo = add(2);
      console.log(addTwo(3)); // 5
        </pre>
        </div>

        <div>
            <!-- ➡️ Arrow Functions -->
            <!-- Arrow functions provide a shorter syntax for writing functions 
                and do not have their own `this`. -->
            <pre>
      const add = (a, b) => a + b;
        </pre>
        </div>

        <div>
            <!-- 📦 IIFE -->
            <!-- Immediately Invoked Function Expression
                 is a function that runs as soon as it is defined. -->
            <pre>
      (function() {
        console.log('IIFE');
      })();
        </pre>
        </div>

        <div>
            <!-- 🔑 this keyword -->
            <!-- `this` refers to the object it belongs to. -->
            <pre>
      const obj = {
        name: "John",
        greet: function() {
          console.log(this.name);
        }
      };
      obj.greet(); // John
        </pre>
        </div>

        <div>
            <!-- ➡️ Arrow function and this keyword -->
            <!-- Arrow functions do not have their own `this` 
                context and inherit it from the enclosing scope. -->
            <pre>
      const obj = {
        name: "John",
        greet: () => {
          console.log(this.name); // `this` refers to the global object
        }
      };
      obj.greet(); // undefined
        </pre>
        </div>

        <div>
            <!-- 📞 Call, Apply, Bind -->
            <!-- These methods allow controlling the
                 `this` context of a function. -->
            <pre>
      const obj = { name: "John" };
      function greet() {
        console.log(this.name);
      }
      greet.call(obj); // John
      greet.apply(obj); // John
      const boundGreet = greet.bind(obj);
      boundGreet(); // John
        </pre>
        </div>

        <div>
            <!-- 🔒 Closure and its uses -->
            <!-- Closure is a feature where an inner
                 function has access to the outer function's variables. -->
            <pre>
      function makeCounter() {
        let count = 0;
        return function() {
          count++;
          return count;
        };
      }
      const counter = makeCounter();
      console.log(counter()); // 1
      console.log(counter()); // 2
        </pre>
        </div>

        <div>
            <!-- 🔄 Callbacks, Callback Hell -->
            <!-- Callbacks are functions passed as arguments 
                to other functions to be executed later. Callback hell 
                refers to nested callbacks that are hard to manage. -->
            <pre>
      function doSomething(callback) {
        setTimeout(() => {
          callback('Done');
        }, 1000);
      }
      doSomething((result) => {
        console.log(result); // Done
      });
        </pre>
        </div>

        <div>
            <!-- 🔮 Promises, promise chaining -->
            <!-- Promises represent the eventual completion or failure
                 of an asynchronous operation and allow chaining. -->
            <pre>
      const promise = new Promise((resolve, reject) => {
        setTimeout(() => {
          resolve('Done');
        }, 1000);
      });
      promise.then(result => {
        console.log(result); // Done
      });
        </pre>
        </div>

        <div>
            <!-- ⏳ Async/Await -->
            <!-- Async/await is syntactic sugar over promises 
                for writing asynchronous code. -->
            <pre>
      async function fetchData() {
        const response = await fetch('https://api.example.com/data');
        const data = await response.json();
        console.log(data);
      }
      fetchData();
        </pre>
        </div>

        <div>
            <!-- 🔄 Callbacks vs promises vs async/await -->
            <!-- Callbacks are traditional ways to handle async operations,
                 promises provide better readability and error handling, 
                 async/await offers even cleaner syntax. -->
            <pre>
      function callbackExample(callback) {
        setTimeout(() => callback('Done'), 1000);
      }
      callbackExample(result => console.log(result)); // Done
      
      const promiseExample = new Promise((resolve) => {
        setTimeout(() => resolve('Done'), 1000);
      });
      promiseExample.then(result => console.log(result)); // Done
      
      async function asyncAwaitExample() {
        const result = await new Promise((resolve) => {
          setTimeout(() => resolve('Done'), 1000);
        });
        console.log(result); // Done
      }
      asyncAwaitExample();
        </pre>
        </div>

        <div>
            <!-- 🍛 Currying -->
            <!-- Currying is a technique where a function 
                takes multiple arguments one at a time. -->
            <pre>
      const add = x => y => x + y;
      const addTwo = add(2);
      console.log(addTwo(3)); // 5
        </pre>
        </div>

        <div>
            <!-- 🛠️ Debouncing and Throttling -->
            <!-- Debouncing delays the execution of a function 
                until a certain time has passed. Throttling ensures 
                a function is called at most once in a specified time period. -->
            <pre>
      function debounce(func, wait) {
        let timeout;
        return function(...args) {
          clearTimeout(timeout);
          timeout = setTimeout(() => func.apply(this, args), wait);
        };
      }
      function throttle(func, limit) {
        let inThrottle;
        return function(...args) {
          if (!inThrottle) {
            func.apply(this, args);
            inThrottle = true;
            setTimeout(() => inThrottle = false, limit);
          }
        };
      }
        </pre>
        </div>

        <div>
            <!-- 🔍 Event Propagation -->
            <!-- Event propagation determines how 
                events flow through the DOM tree. -->
            <!-- 🔵 Bubbling -->
            <pre>
      document.getElementById('child').addEventListener('click', () => {
        console.log('Child clicked');
      });
      document.getElementById('parent').addEventListener('click', () => {
        console.log('Parent clicked');
      });
        </pre>
            <!-- 🎣 Capturing -->
            <pre>
      document.getElementById('child').addEventListener('click', () => {
        console.log('Child clicked');
      }, true);
      document.getElementById('parent').addEventListener('click', () => {
        console.log('Parent clicked');
      }, true);
        </pre>
        </div>

        <div>
            <!-- 📦 Event Delegation -->
            <!-- Event delegation allows handling events at a 
                higher level in the DOM instead of setting 
                event listeners for specific nodes. -->
            <pre>
      document.getElementById('parent').addEventListener('click', (event) => {
        if (event.target && event.target.matches('button')) {
          console.log('Button clicked');
        }
      });
        </pre>
        </div>

        <div>
            <!-- 📘 Prototype and Prototypal Inheritance -->
            <!-- JavaScript uses prototypes for inheritance.
                 Objects can inherit properties and methods 
                 from their prototype. -->
            <pre>
      function Person(name) {
        this.name = name;
      }
      Person.prototype.greet = function() {
        console.log(`Hello, ${this.name}`);
      };
      const john = new Person('John');
      john.greet(); // Hello, John
        </pre>
        </div>

        <div>
            <!-- 🧠 Memoization -->
            <!-- 
            Memoization is a technique used in programming to optimize the performance
            of functions by caching the results of expensive function calls and
            returning the cached result when the same inputs occur again.
            This can significantly reduce the time complexity of algorithms,
            especially those with overlapping subproblems,
            such as those found in dynamic programming. -->
            <pre>
      function memoize(fn) {
        const cache = {};
        return function(...args) {
          const key = JSON.stringify(args);
          if (cache[key]) {
            return cache[key];
          }
          const result = fn(...args);
          cache[key] = result;
          return result;
        };
      }
        </pre>
        </div>

        <div>
            <!-- 🌀 Generator Functions -->
            <!-- Generator functions can pause execution and resume
                 later, producing a sequence of values. -->
            <pre>
      function* generateSequence() {
        yield 1;
        yield 2;
        yield 3;
      }
      const generator = generateSequence();
      console.log(generator.next().value); // 1
      console.log(generator.next().value); // 2
      console.log(generator.next().value); // 3
        </pre>
        </div>

        <div>
            <!-- 🔄 Event Loop, Microtasks, Macrotasks -->
            <!-- The event loop handles execution of multiple pieces
                 of JavaScript code including microtasks (e.g., promises)
                  and macrotasks (e.g., setTimeout). -->
            <pre>
      console.log('Start');
      setTimeout(() => {
        console.log('Timeout');
      }, 0);
      Promise.resolve().then(() => {
        console.log('Promise');
      });
      console.log('End');
        </pre>
        </div>

        <div>
            <!-- 🎉 Events: DOMContentLoaded, load, beforeunload, unload -->
            <!-- These events indicate different stages of the page load process. -->
            <pre>
      document.addEventListener('DOMContentLoaded', () => {
        console.log('DOM fully loaded and parsed');
      });
      window.addEventListener('load', () => {
        console.log('Page fully loaded');
      });
      window.addEventListener('beforeunload', (event) => {
        event.returnValue = 'Are you sure you want to leave?';
      });
      window.addEventListener('unload', () => {
        console.log('Page is unloading');
      });
        </pre>
        </div>

        <div>
            <!-- ⏩ async/defer -->
            <!-- `async` loads scripts asynchronously while 
                `defer` loads them after the document is parsed. -->
            <pre>
      <script async src="script.js"></script>
      <script defer src="script.js"></script>
        </pre>
        </div>

        <div>
            <!-- 🩹 Polyfills (Promise, Promise.all, Promise.any, 
                Promise.race, Promise.allSettled, call, apply, bind,
                 map, reduce, filter, forEach, flat, fetch API) -->
            <!-- Polyfills are used to add support for features
                 not available in certain environments. -->
            <pre>
      if (!window.Promise) {
        window.Promise = /* Polyfill code */;
      }
        </pre>
        </div>

        <div>
            <!-- 🌐 Web APIs -->
            <!-- Web APIs provide additional functionalities
                 like network requests, data storage, etc. -->
            <pre>
      const timeoutId = setTimeout(() => {
        console.log('Timeout');
      }, 1000);
      clearTimeout(timeoutId);
      
      const intervalId = setInterval(() => {
        console.log('Interval');
      }, 1000);
      clearInterval(intervalId);
        </pre>
        </div>

        <div>
            <!-- 🔄 High Order Functions -->
            <!-- High order functions take other 
                functions as arguments or return them. -->
            <pre>
      function higherOrderFunction(fn) {
        return function(...args) {
          return fn(...args);
        };
      }
      const double = higherOrderFunction(x => x * 2);
      console.log(double(2)); // 4
        </pre>
        </div>

        <div>
            <!-- 🔧 Working of JS Engine -->
            <!-- 1. Parsing: The JS engine parses the source 
                code into an Abstract Syntax Tree (AST). -->
            <!-- 2. Compilation: The engine compiles the AST into bytecode. -->
            <!-- 3. Execution: The bytecode is executed in the JavaScript runtime. -->
            <pre>
            console.log('JavaScript Concepts Explained');
        </pre>
        </div>
    </span>
</body>
<span>
    <!-- Document Object Model (DOM) is a programming interface for HTML
    and XML documents, that allows to create, manipulate,
    or delete the element from the document. It defines the
    logical structure of documents and the way a document
    is accessed and manipulated. With the help of DOM, the
    webpage can be represented in a structured hierarchy,
    i.e., we can easily access and manipulate tags, IDs,
    classes, Attributes, or Elements of HTML using
    commands or methods provided by the Document object,
    that will guide the programmers and users to
    understand the document in an easier manner.

    HTML is used to structure the web pages and Javascript is used to
    add behavior to our web pages. When an HTML file is
    loaded into the browser, the javascript can not understand
    the HTML document directly. So, a corresponding document is
    created(DOM). DOM is basically the representation of the
    same HTML document but in a different format with the use of
    objects. DOM provides several methods to find &
    manipulate the behavior of the HTML element:

    getElementById() Method: This method returns the
    elements that have given an ID which is passed to the function.
    getElementsByClassName() Method: This method in
    Javascript returns an object containing all the elements with the
    specified class names in the document as objects: This
    getElementsByName() Method: This method returns
    the collection of all elements of a particular document by name.
    getElementsByTagName() Method: This method in HTML returns the
    collection of all the elements in the document with the
    given tag name.
    querySelector() Method: This method in HTML is used to return the
    first element that matches a specified CSS selector(s)
    in the document.
    querySelectorAll() Method: This method is used to return a
    collection of an element’s child elements that match a
    specified CSS selector(s), as a static NodeList object.




    Browser Object Model (BOM) is a browser-specific convention
    referring to all the objects exposed by the web browser.
    The BOM allows JavaScript to “interact with” the browser.
    The window object represents a browser window and all its
    corresponding features. A window object is created automatically
    by the browser itself. Java Script’s window.screen object contains
    information about the user’s screen. It can also be written without
    the window prefix. This Object Model supports the following Window properties:

    screen.width: The screen.width property returns the user’s screen width in pixels.
    screen.height: The screen.height property returns the user’s screen height in pixels.
    screen.availWidth: The screen.availWidth property returns the user’s screen width
    in pixels, excluding the interface features.
    screen.availHeight: The screen.availHeight property returns the user’s screen
    height in pixels excluding the interface features.
    screen.colorDepth: The screen.colorDepth property returns
    the bits (number) to be used to display one color.
    screen.pixelDepth: The screen.pixelDepth property returns the pixel depth of the screen.
    The BOM also supports the following Window methods:

    window.open() Method: This method is used to open a new
    tab or window with the specified URL and name.
    window.close() Method: This method, is used for closing a
    certain window or tab of the browser which was previously
    opened by the window.open() method. -->


    <!-- Caching is a technique used in computing to store data
    temporarily so that future requests for that data can be
    served faster. It is a crucial optimization method for
    improving the performance and efficiency of various systems,
    including web servers, databases, and applications.

    Types of Caching
    Memory Cache: Stores data in the memory (RAM) for quick access.
       Commonly used in web browsers and applications.
    Disk Cache: Stores data on disk. It’s slower
       than memory cache but can handle larger amounts of data.
    Distributed Cache: Uses a distributed system to
       cache data across multiple servers. Useful for scaling applications. -->
</span>

<span>
    <!-- Converting Objects to Arrays
    1. Using Object.keys(), Object.values(), and Object.entries()
    Object.keys(obj): Returns an array of the object's own enumerable property names (keys).
    Object.values(obj): Returns an array of the object's own enumerable property values.
    Object.entries(obj): Returns an array of the object's own enumerable [key, value] pairs. -->
    <script>
        const obj = {
            name: "Alice",
            age: 30,
            address: {
                street: "123 Main St",
                city: "Wonderland"
            }
        };
        // Convert object keys to an array
        const keysArray = Object.keys(obj);
        console.log(keysArray); // ["name", "age", "address"]

        // Convert object values to an array
        const valuesArray = Object.values(obj);
        console.log(valuesArray); // ["Alice", 30, { street: "123 Main St", city: "Wonderland" }]

        // Convert object entries to an array of [key, value] pairs
        const entriesArray = Object.entries(obj);
        console.log(entriesArray); // [["name", "Alice"], ["age", 30], ["address", { street: "123 Main St", city: "Wonderland" }]]
    </script>
</span>
<span>
    <!-- Converting Arrays to Objects
    1. Using Array.prototype.reduce()
    You can use the reduce method to transform an array into an object.
    2. Using Object.fromEntries()
    Object.fromEntries is a more straightforward way to convert an array of
     [key, value] pairs back into an object. -->
</span>
<script>
    const keyValuePairs = [
        ["brand", "Toyota"],
        ["model", "Corolla"],
        ["year", 2020]
    ];

    // Using reduce
    const car = keyValuePairs.reduce((obj, [key, value]) => {
        obj[key] = value;
        return obj;
    }, {});

    console.log(car);
    // Output: { brand: "Toyota", model: "Corolla", year: 2020 }

    // Using Object.fromEntries
    const car2 = Object.fromEntries(keyValuePairs);
    console.log(car2);
    // Output: { brand: "Toyota", model: "Corolla", year: 2020 }

</script>

<span>
    forEach: Executes a provided function once for each array element. It doesn't create a new array but is used when
    you want to perform an operation for each element without needing to produce a new array as a result.

    map: Creates a new array by calling a provided function on every element in the array. It returns a new array with
    the results of calling the provided function on each element. It's useful when you want to transform each element of
    the array and produce a new array with the transformed elements.
</span>
<script>

// let arr=[1,2,3,4,5,6,7,]
// let arr2=arr.map((x)=>{
//     return x*2
// })
// console.log(arr2)


// let arr=[1,2,3,4,5,6,7,]
// let arr2=arr.filter((x)=>{
//     return x%2==0
// })
// console.log(arr2)

// let arr=[1,2,3,4,5,6,7,6]
// let arr2=[]
// arr.forEach((x)=>{
//     return arr2.push(x*2)
// })
// console.log(arr2)

</script>

</html>
<script>
    let person = {
        name: "Alice",
        age: 30,
        hobbies: ["reading", "hiking", "cooking"]
    };
    console.log("jsonString", JSON.stringify(person));
    //output=jsonString {"name":"Alice","age":30,"hobbies":["reading","hiking","cooking"]}

    let person2 = '{"name":"Alice","age":30,"hobbies":["reading","hiking","cooking"]}'
    console.log("jsonParse", JSON.parse(person2));

    //output

</script>