<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
</body>

</html>
<script>
    // function currying(x) {
    //     return function (y) {
    //         return function (z) {
    //             return x + y + z;
    //         };
    //     };
    // }

    // const curriedFunction = currying(5)(2)(3);
    // console.log("curry", curriedFunction); // Outputs: "curry 10"
    // function currying(x,y,z){
    //     return x + y + z;
    // }
    // console.log("curry",currying(5,2,3))



    // Another way to use the curried function
    // const add5 = currying(5);
    // const add5And2 = add5(2);
    // const result = add5And2(3);
    // console.log("curry", result); // Outputs: "curry 10"
    // function currying(x,y,z){
    //     return x + y + z;
    // }
    // console.log("curry",currying(5,2,3))
    // function curry(x) {
    //     return function (y) {
    //         return function (z) {
    //             return x + y + z
    //         }
    //     }
    // }
    // console.log("curried",curry(5)(2)(2))

</script>
<script>
    console.log([1, 2, 3, 4].map((x) => (x > 3)))
    // Output: [false, false, false, true]
    //  The map function in JavaScript creates a new array
    //   populated with the results of calling a provided
    //     function on every element in the calling array.
    //    The function provided to map does not change the 
    //    values of the elements directly; instead, it 
    //    returns new values based on the computation
    //     within the function.

    // In  code console.log([1, 2, 3, 4].map((x) => (x > 3))),
    //         the provided function (x) => (x > 3) performs 
    //  a comparison operation that returns true or false
    //     for each element in the array. 
    //   Here is why it doesn't print 1, 2:

    // Original Array: [1, 2, 3, 4]

    // Mapping Function: (x) => (x > 3)

    // For x = 1: 1 > 3 evaluates to false
    // For x = 2: 2 > 3 evaluates to false
    // For x = 3: 3 > 3 evaluates to false
    // For x = 4: 4 > 3 evaluates to true
    // New Array: The map function collects these 
    // results and creates a new array:
    //     [false, false, false, true].

    // The key point is that map returns a new
    //     array based on the return values of the
    //     function provided for each element, not the 
    //     original elements themselves.Since the function
    //     (x > 3) only returns true or false, the resulting
    //     array contains boolean values, not the original numbers.

    // If you want to filter the array to include only
    //  numbers greater than 3, you should use the filter method instead:
    console.log([1, 2, 3, 4].filter((x) => (x > 3)));
    //Output: [4]
    //The filter method returns a new array with all elements that pass the
    //test implemented by the provided function,
    //which in this case are the numbers greater than 3.



    //Note: //if you want to use a function within map that checks certain
    //conditions and returns true or false based on those 
    //conditions, you can do so.The map function will then 
    //return an array of true and false values corresponding 
    //to each element in the original array. or 

    // if you want to conditionally include or exclude elements
    //  from the resulting array based on some criteria, 
    //  you can use a callback function with map(). 
    //  This callback function should return the new value
    //   for each element, or undefined if you want to exclude it.

    // const numbers = [1, 2, 3, 4, 5];
    // const evenNumbers = numbers.map(num => {
    //     if (num % 2 === 0) {
    //         return num;
    //     }
    // });
    // console.log(evenNumbers); // Output: [undefined, 2, undefined, 4, undefined]


    // The forEach method in JavaScript is used to execute a provided function
    //  once for each array element. Unlike map, forEach does not create a new array; 
    // it simply iterates over the array and performs the specified action for each element.
    //array.forEach(callback(currentValue, index, array), thisArg);
    // The provided callback function is executed once for 
    // each element in the array in ascending order. 
    // It doesn't modify the array directly 
    // (though it can modify the array elements if desired).

    const numbers = [1, 2, 3, 4, 5];
    numbers.forEach((number, index, array) => {
        array[index] = number * 2;
        console.log(`Index: ${index}, Value: ${array[index]}`);
    });
    // Logs the index and the modified value
    console.log(numbers);
    // Logs the final modified array
    // Index: 0, Value: 2
    // Index: 1, Value: 4
    // Index: 2, Value: 6
    // Index: 3, Value: 8
    // Index: 4, Value: 10
    // [2, 4, 6, 8, 10]


    // Nullish Coalescing Operator (??) and Logical OR Operator (||)

    // Nullish Coalescing Operator (??):
    // Purpose: Provides a default value if the original value is null or undefined.
    // Syntax: let result = leftOperand ?? rightOperand;
    // let a = null;
    // let b = '';
    // console.log(a ?? 'default'); // 'default'
    // console.log(b ?? 'default'); // ''

    // Logical OR Operator (||):
    // Purpose: Provides a default value if the original value is
    //  any falsy value (false, 0, -0, 0n, "", null, undefined, NaN).
    // Syntax: let result = leftOperand || rightOperand;
    // let a = null;
    // let b = '';
    // console.log(a || 'default'); // 'default'
    // console.log(b || 'default'); // 'default'
    // Key Differences:
    // ?? checks specifically for null or undefined.|| checks for any falsy value.
    // Use Cases:
    // Use ?? when you want to provide a default value only for
    //  null or undefined, allowing other falsy
    //   values (0, '', false, etc.) to be valid.
    // Use || when you want to provide a default
    //  value for any falsy value.


    // && (AND):

    // Returns the first falsy value encountered or the last value if all are truthy.
    // Short-circuits (stops evaluating) when a falsy value is found.
    // Commonly used to ensure multiple conditions are true before executing a block of code.
    // || (OR):

    // Returns the first truthy value encountered or the last value if all are falsy.
    // Short-circuits when a truthy value is found.
    // Commonly used to provide default values.
</script>

<!-- Minification is the process of reducing the size of a source code file by removing unnecessary characters and formatting
elements, without affecting its functionality. It is commonly used in web development and software distribution to
optimize file sizes for improved performance and user experience. Minification tools and build automation techniques
simplify the process and make it easy to incorporate into development workflows. -->

<body>
    <!-- JavaScript
    Definition: JavaScript is a high-level, interpreted programming language that is primarily used for client-side
    scripting in web browsers.
    Execution: JavaScript code is executed by JavaScript engines embedded in web browsers (such as V8 in Chrome,
    SpiderMonkey in Firefox, etc.).
    Process: JavaScript is typically written in plain text (source code), which is directly interpreted by the
    JavaScript engine. There is no separate compilation step like other languages that produce bytecode or
    binary code.
    Performance: Modern JavaScript engines often employ Just-In-Time (JIT) compilation to convert JavaScript code to
    machine code (binary code) on the fly for performance optimization.
    Example:
    javascript
    Copy code
    console.log("Hello, World!");
    Use Case: Web development, including both client-side (browser) and server-side (with environments like Node.js). -->

    <!-- Typescript
    TypeScript is a Strongly Typed programming language that supports both dynamic and static typing. It provides
    classes, visibility scopes, namespaces, inheritance, unions, interfaces, and many other features.
    Also, it offers comments, variables,
    statements, expressions, modules, and functions.

    You can execute it on Node.Js or any other browser that supports ECMAScript 3 or its latest versions.
    Since TypeScript is an enhanced version of JavaScript, all code of JavaScript is syntactically valid TypeScript.
    However, it doesn’t mean the TypeScript compiler can process all JavaScript:
    let a = 'a'; a = 1; // throws: error TS2322: Type '1' is not assignable to type 'string'.

    Any & Unknown
    A type called Any (anything that you wish) can cover unknown
     is its type-safe system. Here, any allows you to assign
    and JavaScript variable whenever you want to escape the type system. 
    It’s widely used to describe incoming variables
    that haven’t been validated yet and whose type is
     unknown (for example, from third-party APIs).

    TypeScript supports abstraction through interfaces, while JavaScript does not.
    
    Unknown is similar to Any, but it will not allow you 
    to do anything with it unless it’s explicitly type-checked.?

    Void
    When there is no value returned, Void is used.
     Generally, it’s used for the return type of function that returns
    nothing.

    Never
    Never is the return type for something that
     should never happen, such as an exception-throwing function. -->

    <!-- 
    Static Typing
    Definition: In statically typed languages, type checking is performed at compile time,
     before the code is executed.

    Key Characteristics:

    Type Declarations: Variables must be explicitly declared
     with a type (e.g., int, string) when they are defined.

    Compile-Time Checking: The compiler checks the types of
     variables and expressions during compilation. Errors are
    caught early, before the program runs.

    Performance: Since type checking is done at compile time, 
    the runtime can be more optimized. The compiler can
    generate more efficient machine code.

    Error Detection: Type errors are detected early in the development
     process, which can prevent certain types of bugs
    from occurring at runtime.

    IDE Support: Static typing provides better support for 
    integrated development environments (IDEs) with features like
    autocomplete, refactoring, and type checking.
    Examples of Statically Typed Languages:

    Java
    C++
    C#
    Swift
    TypeScript (superset of JavaScript)
    
    Example:
    java
    Copy code
    int count = 10; // Declared as an integer
    count = "Hello"; // Compile-time error: Type mismatch
    Dynamic Typing
    Definition: In dynamically typed languages, type checking is performed at runtime, when the code is executed.

    Key Characteristics:

    Implicit Types: Variables are not explicitly declared with a type.
     The type is inferred from the value assigned to
    the variable.

    Runtime Checking: Types are checked during program execution.
     This allows for more flexible and expressive code but
    can lead to runtime errors.

    Flexibility: Dynamic typing allows for rapid prototyping and shorter code,
     as there is less need for explicit type
    declarations.

    Performance: Runtime type checking can introduce overhead,
     potentially making dynamically typed languages slower
    than statically typed ones.

    Error Detection: Type errors are caught only when the
     affected code paths are executed, which can make debugging
    more challenging.
    Examples of Dynamically Typed Languages:
    JavaScript
    Python
    Ruby
    PHP
    Perl

    Example:
    python
    count = 10 # Initially assigned an integer
    count = "Hello" # No error at assignment; type is changed to string
    print(count + 5) # Runtime error: Can't concatenate str and int

    Summary of Differences
    When Types Are Checked:


    Static Typing: At compile time.
    Dynamic Typing: At runtime.

    Type Declarations:
    Static Typing: Explicit type declarations are required.
    Dynamic Typing: Types are inferred and can change dynamically.
    Error Detection:
    Static Typing: Errors are caught during compilation, before execution.
    Dynamic Typing: Errors are caught during execution,
    which can lead to runtime crashes if not properly handled.
    Performance:
    Static Typing: Generally more efficient at runtime due to optimized machine code.
    Dynamic Typing: Can be less efficient due to the overhead of runtime type checking -->


    <!-- The difference between an interpreted and a compiled language lies in the result
     of the process of interpreting or compiling. An interpreter produces a result from 
     a program, while a compiler produces a program written in assembly language -->


</body>
<script>

    // function add(a, b) {
    //     return a + b
    //     setInterval(() => {
    //         console.log(((b, d) => {
    //             return b + d;
    //         })
    //             (2, 3))
    //     }, 1000)
    // }
    // add(2, 4)
    // console.log(add(2, 4))
    // In your provided code, the setInterval function is placed after
    //  the return statement in the add function. This means that the
    // return statement will exit the function immediately, and the
    //  code after it won't be executed. To correct this and make sure the setInterval
    // function works as expected, you should place it before the return statement

    // function add(a, b) {
    //     setInterval(() => {
    //         const result = (b, d) => {
    //             return b + d;
    //         };
    //         console.log(result(2, 3)); // This will log 5 every 1 second
    //     }, 1000);
    //     return a + b;
    // }
    // add(2, 4);

    // console.log("Time in");
    // let i = 0;
    // let id = setInterval(() => {
    //     console.log(i++);
    //     if (i === 10) {
    //         clearInterval(id);
    //         console.log("Timeout");
    //     }
    // }, 1000);
</script>

<script>
    
// Anonymous:

// Arrow Functions: Can be created without a name, often used for inline functions.
// Normal Functions: Typically named, which is useful for debugging and self-documenting code.
// Syntax:

// Arrow Functions: Use a more concise syntax (=>).
// Normal Functions: Use the traditional function keyword, resulting in more verbose code.
// Handling multiple expressions:

// Arrow Functions: Less intuitive when handling multiple statements due to needing explicit {} and return.
// Normal Functions: More straightforward when handling multiple statements.
// this keyword behavior:

// Arrow Functions: Lexically bind this, meaning they inherit this from the parent scope.
// Normal Functions: Bind this to the object that calls the function, making them useful for methods.
// Constructor functionality:

// Arrow Functions: Cannot be used as constructors and will throw an error if used with new.
// Normal Functions: Can be used as constructors with the new keyword to create instances.
// Arguments object:

// Arrow Functions: Do not have their own arguments object; use rest parameters (...args) instead.
// Normal Functions: Have their own arguments object, which is an array-like object accessible within the function.
// Duplicate named parameters:

// Arrow Functions: ES6 strict mode disallows duplicate named parameters in arrow functions.
// Normal Functions: Allow duplicate named parameters (not recommended, though).
// call, apply, and bind:

// Arrow Functions: The methods call, apply, and bind do not change the this value.
// Normal Functions: These methods can change the this value within the function.
// Scoping:

// Arrow Functions: Lexically scoped, which means the this value is determined
//     by the surrounding code context where the arrow function is defined.
// Normal Functions: Functionally scoped, meaning this is determined by how the function is called.

// Anonymous
const arrowGreet = () => {
    console.log("Hello from Arrow Function!");
  };
  function normalGreet() {
    console.log("Hello from Normal Function!");
  }
  arrowGreet(); // Output: Hello from Arrow Function!
  normalGreet(); // Output: Hello from Normal Function!
  
  // Syntax
  const arrowAdd = (a, b) => a + b;
  function normalAdd(a, b) {
    return a + b;
  }
  console.log(arrowAdd(2, 3)); // Output: 5
  console.log(normalAdd(2, 3)); // Output: 5
  
  // Handling Multiple Expressions
  const arrowComplexOperation = (a, b) => {
    const result = a + b;
    return result * 2;
  };
  function normalComplexOperation(a, b) {
    const result = a + b;
    return result * 2;
  }
  console.log(arrowComplexOperation(2, 3)); // Output: 10
  console.log(normalComplexOperation(2, 3)); // Output: 10
  
  // `this` Keyword Behavior
  const arrowObj = {
    value: 10,
    increment: () => {
      console.log(this.value); // undefined, inherits `this` from the global scope
    }
  };
  const normalObj = {
    value: 10,
    increment: function() {
      console.log(this.value); // 10, `this` refers to `normalObj`
    }
  };
  arrowObj.increment();
  normalObj.increment();
  
  // Constructor Functionality
  const ArrowPerson = (name) => {
    this.name = name;
  };
  // const arrowPerson = new ArrowPerson("John"); // Error: ArrowPerson is not a constructor
  
  function NormalPerson(name) {
    this.name = name;
  }
  const normalPerson = new NormalPerson("John");
  console.log(normalPerson.name); // Output: John
  
  // Arguments Object
  const arrowShowArgs = (...args) => {
    console.log(args); // Uses rest parameters
  };
   
  arrowShowArgs(1, 2, 3); // Output: [1, 2, 3]
  normalShowArgs(1, 2, 3); // Output: [Arguments] { '0': 1, '1': 2, '2': 3 }
  
  // Duplicate Named Parameters
  // const arrowFunc = (a, a) => a; // SyntaxError: Duplicate parameter name not allowed
  function normalFunc(a, a) {
    return a;
  }
  console.log(normalFunc(1, 2)); // Output: 2
  
  // `call`, `apply`, and `bind`
  const arrowFuncCall = () => {
    console.log(this);
  };
  function normalFuncCall() {
    console.log(this);
  }
  arrowFuncCall.call({ name: "Alice" }); // Output: Window (or global object in Node.js)
  normalFuncCall.call({ name: "Alice" }); // Output: { name: "Alice" }
  
  // Scoping
  const arrowOuterFunc = () => {
    return () => {
      console.log(this); // Inherits `this` from the arrowOuterFunc scope
    };
  };
  function normalOuterFunc() {
    return function() {
      console.log(this); // `this` is determined by the call
    };
  }
  arrowOuterFunc().call({ name: "Alice" }); // Output: Window (or global object in Node.js)
  normalOuterFunc().call({ name: "Alice" }); // Output: { name: "Alice" }
  


  /////

// mapfilterreduce
// forEach().map() -> No: forEach() doesn't return an array, so map() cannot be chained to it.
// map().forEach() -> Yes: Since map() returns an array, forEach() can be chained to iterate over the mapped array.
// filter().reduce() -> Yes: filter() returns an array, and reduce() can be chained to it to reduce the filtered array to a single value.
// map().filter() -> Yes: map() returns an array, and filter() can be chained to it to filter the mapped array.
// forEach().filter() -> No: forEach() doesn't return an array, so filter() cannot be chained to it.
const bag = [
    { title: "Apple" },
    { title: "Banana" },
    { title: "Orange" },
    { title: "Grapes" }
  ];
  const e = "a"; // searching for titles containing 'a'
  let newData = bag.filter((elem) => elem.title.toLowerCase().includes(e.toLowerCase()));
  console.log(newData);
  // Output: [
  //   { title: "Apple" },
  //   { title: "Banana" },
  //   { title: "Orange" },
  //   { title: "Grapes" }
  // ]
  
  // const bag = ["Apple", "Banana", "Orange", "Grapes"];
  // const e = "a"; // searching for strings containing 'a'
  // let newData = bag.filter((str) => str.toLowerCase().includes(e.toLowerCase()));
  // console.log(newData);
  // // Output: ["Apple", "Banana", "Orange", "Grapes" ]

  // The includes method checks if an array contains a specific element.
  //  It returns true if the element is found, and false
let fruits = ["apple", "banana", "mango", "orange"];
let hasMango = fruits.includes("mango");
console.log(hasMango); // Output: true

//deep.js

// Returning Functions (Closures):
// Functions in JavaScript can also return other functions. 
// This is often used to create closures, where the inner 
// function has access to the variables of the outer function 
// even after the outer function has finished executing.

function outer() {
    var a = 10;

    function inner() {
        console.log(a); // Accesses the 'a' variable from the outer function
    }
    return inner;
}
var closureFunction = outer();
closureFunction(); // Outputs: 10
// When closureFunction() is called, it:
// Executes the inner function.
// The inner function logs the value of a to the console.
// Since inner is a closure, it retains access to the variable
// a from the scope in which it was created, 
// which is the outer function's scope.

// outer() is called, and it returns the inner function.
// closureFunction holds the reference to the returned inner function.
// When closureFunction() is called, it executes the inner function.
// The inner function logs the value of a (which is 10) to the
//  console because it has access to the a variable through closure.
//

function outer() {
    var a = 10;
    function inner() {
        return a;
    }
    return inner;
}
console.log(outer()())//10
// When outer is called, it:

// Declares a variable a with the value 10.
// Defines an inner function inner that returns the value of a.
// Returns the inner function.
// Execution of the returned function:

// outer() returns the inner function.
// The returned inner function is then immediately invoked by the second pair of parentheses ().
// Return value of inner:
// return a;
// The inner function returns the value of a, which is 10.
// Output of console.log:
// console.log(outer()()) logs the return value of the inner function, which is 10



// ///
// function outer() {
//     var a = 10;

//     function inner() {
//         console.log(a);
//     }

//     return inner;
// }
// console.log(outer()())

// outer() is called, which returns the inner function.
// The returned inner function is immediately invoked.
// Inside inner, it logs the value of a (which is 10).
// The result of this process will be:

// 10
// undefined
// The undefined is the result of console.log(outer()()). 
// The inner function doesn't return a value; it only logs 
// the value of a. Therefore, the overall expression
//  console.log(outer()()) logs 10 from the inner function
//   and then undefined because inner doesn't return anything.


///

// function outer() {
//     var a = 10;
//     function inner() {
//         console.log(a);
//     }
//     return inner;
// }
// console.log(outer())

// ƒ inner() {
//     console.log(a);
// }
// This output is a string representation of the inner function,
//  indicating that outer() returned the inner function itself.


// const products = [
//     { id: 1, name: "Laptop", price: 1000 },
//     { id: 2, name: "Phone", price: 700 },
//     { id: 3, name: "Tablet", price: 500 }
//   ];
//   const laptop = console.log(products.find(product => product.name === "Laptop"));
  // laptop is { id: 1, name: "Laptop", price: 1000 } 
  // const WSort=products.sort((a,b)=>(a.price-b.price))
  // console.log(WSort)
  // console.log([1,2,56,76,3,4].sort((a,b)=>(a-b)))



//   Definition: The slice method returns a shallow copy of a portion of an array or string into 
//   a new array or string object selected from start to end (end not included).
//   The original array or string will not be modified.

// Syntax:

// For arrays: array.slice(start, end)
// For strings: string.slice(start, end)

// Parameters:
// start: The zero-based index at which to begin extraction.
// end (optional): The zero-based index before which to end extraction.
// The element at this index will not be included. If omitted,
// extraction goes till the end of the array/string.
// Examples:

// Array:
// let fruits = ["Banana", "Orange", "Lemon", "Apple", "Mango"];
// let citrus = fruits.slice(1, 3);
// // citrus contains ["Orange", "Lemon"]
// // fruits remains unchanged
// String:

// let text = "Hello World";
// let part = text.slice(0, 5);
// // part contains "Hello"
// // text remains unchanged
// Splice
// Definition: The splice method changes the contents of an array by removing 
// or replacing existing elements and/or adding new elements in place. 
// This method directly modifies the original array.

// Syntax: array.splice(start, deleteCount, item1, item2, ...)

// Parameters:

// start: The index at which to start changing the array.
// deleteCount (optional): The number of elements to remove. If 0, no elements are removed.
// item1, item2, ... (optional): The elements to add to the array, beginning at the start index.
// Examples:

// Remove elements:

// let fruits = ["Banana", "Orange", "Lemon", "Apple", "Mango"];
// let removed = fruits.splice(2, 2);
// // removed contains ["Lemon", "Apple"]
// // fruits is now ["Banana", "Orange", "Mango"]
// Replace elements:

// let fruits = ["Banana", "Orange", "Lemon", "Apple", "Mango"];
// let replaced = fruits.splice(2, 1, "Grapes");
// // replaced contains ["Lemon"]
// // fruits is now ["Banana", "Orange", "Grapes", "Apple", "Mango"]
// Add elements:
// let fruits = ["Banana", "Orange", "Lemon", "Apple", "Mango"];
// fruits.splice(2, 0, "Kiwi", "Pineapple");
// // fruits is now ["Banana", "Orange", "Kiwi", "Pineapple", "Lemon", "Apple", "Mango"]
// Key Differences

// Purpose:
// slice is used for creating a new array or string without modifying the original.
// splice is used for adding/removing/replacing elements in an array, modifying the original array.

// Modification:
// slice does not modify the original array/string.
// splice modifies the original array.

// Return Value:
// slice returns a new array/string.
// splice returns an array containing the deleted elements.
</script>